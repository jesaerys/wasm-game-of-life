# Notes on the "Rust and WebAssembly" book

https://rustwasm.github.io/docs/book/introduction.html


## 4.1. Setup

Installed `wasm-pack` using `cargo install wasm-pack`.

Installed `nvm` using the the official install script, then installed the latest
`npm` with `nvm install node`.


## 4.2. Hello, World!

`src/lib.rs` is a little different than what's shown in the book, but it seems
to be basically the same. Same for the content generated by `wasm-pack build` in
the `pkg` directory.

Running `npm init wasm-app www` resulted in cloning the
[create-wasm-app](https://github.com/rustwasm/create-wasm-app) repo, commit
`9ac3dff` on branch `master`, into the `www` directory. I removed `www/.git`.

Tried running `npm run start` in the `www` directory, but got an error about
`ERR_OSSL_EVP_UNSUPPORTED`:

```console
$ npm run start

> create-wasm-app@0.1.0 start
> webpack-dev-server

(node:2431) [DEP0111] DeprecationWarning: Access to process.binding('http_parser') is deprecated.
(Use `node --trace-deprecation ...` to show where the warning was created)
ℹ ｢wds｣: Project is running at http://localhost:8080/
ℹ ｢wds｣: webpack output is served from /
ℹ ｢wds｣: Content not from webpack is served from /Users/jake/Documents/wasm-game-of-life/www
node:internal/crypto/hash:68
  this[kHandle] = new _Hash(algorithm, xofLen);
                  ^

Error: error:0308010C:digital envelope routines::unsupported
    at new Hash (node:internal/crypto/hash:68:19)
    at Object.createHash (node:crypto:138:10)
    at module.exports (/Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/util/createHash.js:135:53)
    at NormalModule._initBuildHash (/Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/NormalModule.js:417:16)
    at handleParseError (/Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/NormalModule.js:471:10)
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/NormalModule.js:503:5
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/NormalModule.js:358:12
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/loader-runner/lib/LoaderRunner.js:373:3
    at iterateNormalLoaders (/Users/jake/Documents/wasm-game-of-life/www/node_modules/loader-runner/lib/LoaderRunner.js:214:10)
    at Array.<anonymous> (/Users/jake/Documents/wasm-game-of-life/www/node_modules/loader-runner/lib/LoaderRunner.js:205:4)
    at Storage.finished (/Users/jake/Documents/wasm-game-of-life/www/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js:43:16)
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js:79:9
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/graceful-fs/graceful-fs.js:78:16
    at FSReqCallback.readFileAfterClose [as oncomplete] (node:internal/fs/read/context:68:3) {
  opensslErrorStack: [ 'error:03000086:digital envelope routines::initialization error' ],
  library: 'digital envelope routines',
  reason: 'unsupported',
  code: 'ERR_OSSL_EVP_UNSUPPORTED'
}

Node.js v21.6.2
```

This error seems to date back to around 2021 with the release of Node.js 17.0.0.
From the [release notes](
https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V17.md#17.0.0),

> If you hit an `ERR_OSSL_EVP_UNSUPPORTED` error in your application with
> Node.js 17, it’s likely that your application or a module you’re using is
> attempting to use an algorithm or key size which is no longer allowed by
> default with OpenSSL 3.0. A command-line option, `--openssl-legacy-provider`,
> has been added to revert to the legacy provider as a temporary workaround for
> these tightened restrictions.

I'm not sure yet what exactly (e.g., which module or dependency) is attempting
to use a disallowed algorithm or key size, but commit 9ac3dff of the
create-wasm-app repo dates back to 2020, before the release of Node.js 17.0.0,
and I'm currently running v21.

Anyway, enabled the recommended switch and it worked:

```
NODE_OPTIONS=--openssl-legacy-provider npm run start
```


## 4.3. Rules

Starting with,
```
◻️◻️◻️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◻️◻️◻️
```

and then,
```
◻️◻️◻️◻️◻️
◻️◻️◻️◻️◻️
◻️◾️◾️◾️◻️
◻️◻️◻️◻️◻️
◻️◻️◻️◻️◻️
```

the cell at row 2, column 1 (2,1) dies because it only has one live neighbor.
Same for 2,3. Cell 2,2 stays alive because it has two live neighbors. The only
dead cells that have exactly three live neighbors are 1,2 and 3,1, causing them
to come alive. This leads to the same grid as the initial state:
```
◻️◻️◻️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◻️◻️◻️
```

One example of a stable initial state is,
```
◻️◻️◻️◻️
◻️◾️◾️◻️
◻️◾️◾️◻️
◻️◻️◻️◻️
```

because none of the dead cells have any more than two live neighbors so they all
remain dead, while each live cell has exactly three live neighbors and therefore
remains alive.


## 4.4. Implementing Life

For the exercise on single-bit representation, I had no idea how to do it. All
of the rust docs I read showed the smallest data types taking at least a full
byte. In [a particular discussion thread](
https://users.rust-lang.org/t/is-there-a-one-bit-value-type-in-rust/64816), the
recommendation was to use a third-party crate. Sure enough, the first sentence
in the book's solution mentions using the `fixedbitset` crate.

Using that hint, I attempted to implement the rest on my own. After reading
through the `fixedbitset` docs, I was able to work out how to do most of the
refactoring. I needed help with the pointer part, though, so I used the solution
to learn how to do that. On the javascript side, the solution for determining
whether a particular bit is enabled (i.e., whether a cell is alive) involved
some bit manipulation:

```javascript
const bitIsSet = (n, arr) => {
  const byte = Math.floor(n / 8);
  const mask = 1 << (n % 8);
  return (arr[byte] & mask) === mask
}
```

Bit manipulation is unfamiliar to me, so I decided to spend some time
understanding how the `bitIsSet` function works.

* The arguments `arr` and `n` correspond to the `Uint8Array` overlay array and
  the flattened index of the cell, respectively.

  * `Uint8Array` is a *byte* array that overlays the `FixedBitSet` of bits on
    the Rust side. Each byte in `arr` represents a group of eight cells (bits),
    and the value of the byte uniquely encodes which of those cells are alive
    and which are dead.

  * The "flattened" index being that derived from the row and column of the
    cell in the 2D grid, `row * width + column`.

  * E.g., `n = 21` refers to the 22nd bit in the `FixedBitSet`, corresponding to
    the sixth bit (`n % 8 = 5`) in the third byte (`floor(n / 8) = 2`) in `arr`:

    ```
                 bit: 7 6 5 4  3 2 1 0
    byte 0 (arr[0])  [0 0 0 0  0 0 0 0] <- FixedBitSet[0]
    byte 1 (arr[1])  [0 0 0 0  0 0 0 0] <- FixedBitSet[8]
    byte 2 (arr[2])  [0 0 0 0  0 0 0 0]
    ...                   ^          ^ FixedBitSet[16]
                    FixedBitSet[21]
    ```

* `byte` is the byte that bit `n` belongs to. If `n` is 21, then `byte` is 2.

* `n % 8` is the position of the bit in its byte. If `n` is 21, then `n % 8` is
  5.

* `<<` is the left shift operator. It takes the first argument and shifts its
  binary form to the left the number of places indicated by the second argument,
  bringing in zeros on the right as needed. For example,
  
  ```
  1 << 5
  = 00000001 << 5
  = 00100000 (shift to the left 5 places)
  = 32
  ```

* `mask` is therefore a pattern indicating the bit of interest in the byte: it's
  1 at the bit corresponding to `n` and 0 elsewhere. If `n` is 21, then `mask`
  is 1 at the sixth bit, `00100000` (`1 << (n % 8) = 1 << 5 = 32 = 00100000`.

* `arr[byte] & mask` is the bitwise AND between the byte containing bit `n` and
  `mask`. The bitwise AND operation produces a new byte that has a 1 only where
  the two input bytes both have a 1. Therefore, because `mask` is 0 everywhere
  except for at the position of interest (`n % 8`), the result will equal `mask`
  only if that bit is enabled. For instance, assuming `n` is 21 such that `mask`
  is `00100000`,

  * If `arr[byte]` is `01010101`, then `arr[byte] & mask` is `00000000`, which
    does not equal `mask`, therefore bit `n` is not enabled (the cell is dead).

  * If `arr[byte]` is `01110101`, then `arr[byte] & mask` is `00100000`, which
    *does* equal `mask`, therefore bit `n` *is* enabled (the cell is alive).


## 4.5. Testing Life

### `wasm-bindgen` limitations

This chapter introduces two new methods on `Universe`:
* `get_cells(&self) -> &[Cell]`
* `set_cells(&mut self, cells: &[(u32, u32)]) -> ()`

It states that these methods must go in an `impl Universe` block without the
`#[wasm-bindgen]` attribute. I tried putting them in the impl block with the
`#[wasm-bindgen]` attribute to see what would happen. I got the following error
for `get_cells`:

```
error: cannot return a borrowed ref with #[wasm_bindgen]
  --> src/lib.rs:59:32
   |
59 |     pub fn get_cells(&self) -> &[Cell] {
   |                                ^^^^^^^

error: could not compile `wasm-game-of-life` (lib) due to 1 previous error
```

The chapter mentions,

> Rust-generated WebAssembly functions cannot return borrowed references.

That's exactly the case for `get_cells`, which returns a slice of cells, and the
error from `cargo` explicitly says that's not supported by `#[wasm-bindgen]`.

For `set_cells`, the error from `cargo` was,

```
error[E0277]: the trait bound `[(u32, u32)]: RefFromWasmAbi` is not satisfied
  --> src/lib.rs:52:1
   |
52 | #[wasm_bindgen]
   | ^^^^^^^^^^^^^^^ the trait `RefFromWasmAbi` is not implemented for `[(u32, u32)]`
   |
   = help: the following other types implement trait `RefFromWasmAbi`:
             [isize]
             [i8]
             [i16]
             [i32]
             [i64]
             [usize]
             [u8]
             [u16]
           and 4 others
   = note: this error originates in the attribute macro `wasm_bindgen::prelude::__wasm_bindgen_class_marker` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `wasm-game-of-life` (lib) due to 1 previous error
```

From the `wasm_bindgen` API docs, `RefFromWasmAbi` is,

> A trait for anything that can be recovered as some sort of shared reference
> from the wasm ABI boundary.

It's implemented for `str` and `[T]`, where `T` includes most primitive types
(such as `u32`), but *not* tuples, hence the error. One workaround would be to
receive the row and column indices in separate slices, e.g.,
`set_cells(&mut self, rows: &[u32], cols: &[u32])`, and zip them together.
However, that's unnecessary because the purpose of these methods is to help with
testing, so they don't need to be available to javascript.


### Running the tests

The first time I tried running `wasm-pack test`, I got a weird SIGKILL thing and
it just hung there until I hit `ctrl-C`:

```
$ wasm-pack test --firefox --headless
...
     Running tests/web.rs (target/wasm32-unknown-unknown/debug/deps/web-29967d765c7c8c74.wasm)
Set timeout to 20 seconds...
Running headless tests in Firefox on `http://127.0.0.1:57679/`
Try find `webdriver.json` for configure browser's capabilities:
Not found
driver status: signal: 9 (SIGKILL)

```

I'm not sure what cause that, but I tried again and the test completed so it
seems to be working.


## 4.6. Debugging

Seems straightforward. Using `web_sys::console::log` and variants slows down the
program considerably, though, so I omitted the calls to `log!` shown in the book
and I added `#[allow(unused_macros)]` to the `log!` macro definition. Will
definitely make sure to *only* use `log!` for debugging.
