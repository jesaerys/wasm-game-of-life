# Notes on the "Rust and WebAssembly" book

https://rustwasm.github.io/docs/book/introduction.html


## 4.1. Setup

Installed `wasm-pack` using `cargo install wasm-pack`.

Installed `nvm` using the the official install script, then installed the latest
`npm` with `nvm install node`.


## 4.2. Hello, World!

`src/lib.rs` is a little different than what's shown in the book, but it seems
to be basically the same. Same for the content generated by `wasm-pack build` in
the `pkg` directory.

Running `npm init wasm-app www` resulted in cloning the
[create-wasm-app](https://github.com/rustwasm/create-wasm-app) repo, commit
`9ac3dff` on branch `master`, into the `www` directory. I removed `www/.git`.

Tried running `npm run start` in the `www` directory, but got an error about
`ERR_OSSL_EVP_UNSUPPORTED`:

```console
$ npm run start

> create-wasm-app@0.1.0 start
> webpack-dev-server

(node:2431) [DEP0111] DeprecationWarning: Access to process.binding('http_parser') is deprecated.
(Use `node --trace-deprecation ...` to show where the warning was created)
ℹ ｢wds｣: Project is running at http://localhost:8080/
ℹ ｢wds｣: webpack output is served from /
ℹ ｢wds｣: Content not from webpack is served from /Users/jake/Documents/wasm-game-of-life/www
node:internal/crypto/hash:68
  this[kHandle] = new _Hash(algorithm, xofLen);
                  ^

Error: error:0308010C:digital envelope routines::unsupported
    at new Hash (node:internal/crypto/hash:68:19)
    at Object.createHash (node:crypto:138:10)
    at module.exports (/Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/util/createHash.js:135:53)
    at NormalModule._initBuildHash (/Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/NormalModule.js:417:16)
    at handleParseError (/Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/NormalModule.js:471:10)
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/NormalModule.js:503:5
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/webpack/lib/NormalModule.js:358:12
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/loader-runner/lib/LoaderRunner.js:373:3
    at iterateNormalLoaders (/Users/jake/Documents/wasm-game-of-life/www/node_modules/loader-runner/lib/LoaderRunner.js:214:10)
    at Array.<anonymous> (/Users/jake/Documents/wasm-game-of-life/www/node_modules/loader-runner/lib/LoaderRunner.js:205:4)
    at Storage.finished (/Users/jake/Documents/wasm-game-of-life/www/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js:43:16)
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js:79:9
    at /Users/jake/Documents/wasm-game-of-life/www/node_modules/graceful-fs/graceful-fs.js:78:16
    at FSReqCallback.readFileAfterClose [as oncomplete] (node:internal/fs/read/context:68:3) {
  opensslErrorStack: [ 'error:03000086:digital envelope routines::initialization error' ],
  library: 'digital envelope routines',
  reason: 'unsupported',
  code: 'ERR_OSSL_EVP_UNSUPPORTED'
}

Node.js v21.6.2
```

This error seems to date back to around 2021 with the release of Node.js 17.0.0.
From the [release notes](
https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V17.md#17.0.0),

> If you hit an `ERR_OSSL_EVP_UNSUPPORTED` error in your application with
> Node.js 17, it’s likely that your application or a module you’re using is
> attempting to use an algorithm or key size which is no longer allowed by
> default with OpenSSL 3.0. A command-line option, `--openssl-legacy-provider`,
> has been added to revert to the legacy provider as a temporary workaround for
> these tightened restrictions.

I'm not sure yet what exactly (e.g., which module or dependency) is attempting
to use a disallowed algorithm or key size, but commit 9ac3dff of the
create-wasm-app repo dates back to 2020, before the release of Node.js 17.0.0,
and I'm currently running v21.

Anyway, enabled the recommended switch and it worked:

```
NODE_OPTIONS=--openssl-legacy-provider npm run start
```


## 4.3. Rules

Starting with,
```
◻️◻️◻️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◻️◻️◻️
```

and then,
```
◻️◻️◻️◻️◻️
◻️◻️◻️◻️◻️
◻️◾️◾️◾️◻️
◻️◻️◻️◻️◻️
◻️◻️◻️◻️◻️
```

the cell at row 2, column 1 (2,1) dies because it only has one live neighbor.
Same for 2,3. Cell 2,2 stays alive because it has two live neighbors. The only
dead cells that have exactly three live neighbors are 1,2 and 3,1, causing them
to come alive. This leads to the same grid as the initial state:
```
◻️◻️◻️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◾️◻️◻️
◻️◻️◻️◻️◻️
```

One example of a stable initial state is,
```
◻️◻️◻️◻️
◻️◾️◾️◻️
◻️◾️◾️◻️
◻️◻️◻️◻️
```

because none of the dead cells have any more than two live neighbors so they all
remain dead, while each live cell has exactly three live neighbors and therefore
remains alive.


## 4.4. Implementing Life

For the exercise on single-bit representation, I had no idea how to do it. All
of the rust docs I read showed the smallest data types taking at least a full
byte. In [a particular discussion thread](
https://users.rust-lang.org/t/is-there-a-one-bit-value-type-in-rust/64816), the
recommendation was to use a third-party crate. Sure enough, the first sentence
in the book's solution mentions using the `fixedbitset` crate.

Using that hint, I attempted to implement the rest on my own. After reading
through the `fixedbitset` docs, I was able to work out how to do most of the
refactoring. I needed help with the pointer part, though, so I used the solution
to learn how to do that. On the javascript side, the solution for determining
whether a particular bit is enabled (i.e., whether a cell is alive) involved
some bit manipulation:

```javascript
const bitIsSet = (n, arr) => {
  const byte = Math.floor(n / 8);
  const mask = 1 << (n % 8);
  return (arr[byte] & mask) === mask
}
```

Bit manipulation is unfamiliar to me, so I decided to spend some time
understanding how the `bitIsSet` function works.

* The arguments `arr` and `n` correspond to the `Uint8Array` overlay array and
  the flattened index of the cell, respectively.

  * `Uint8Array` is a *byte* array that overlays the `FixedBitSet` of bits on
    the Rust side. Each byte in `arr` represents a group of eight cells (bits),
    and the value of the byte uniquely encodes which of those cells are alive
    and which are dead.

  * The "flattened" index being that derived from the row and column of the
    cell in the 2D grid, `row * width + column`.

  * E.g., `n = 21` refers to the 22nd bit in the `FixedBitSet`, corresponding to
    the sixth bit (`n % 8 = 5`) in the third byte (`floor(n / 8) = 2`) in `arr`:

    ```
                 bit: 7 6 5 4  3 2 1 0
    byte 0 (arr[0])  [0 0 0 0  0 0 0 0] <- FixedBitSet[0]
    byte 1 (arr[1])  [0 0 0 0  0 0 0 0] <- FixedBitSet[8]
    byte 2 (arr[2])  [0 0 0 0  0 0 0 0]
    ...                   ^          ^ FixedBitSet[16]
                    FixedBitSet[21]
    ```

* `byte` is the byte that bit `n` belongs to. If `n` is 21, then `byte` is 2.

* `n % 8` is the position of the bit in its byte. If `n` is 21, then `n % 8` is
  5.

* `<<` is the left shift operator. It takes the first argument and shifts its
  binary form to the left the number of places indicated by the second argument,
  bringing in zeros on the right as needed. For example,
  
  ```
  1 << 5
  = 00000001 << 5
  = 00100000 (shift to the left 5 places)
  = 32
  ```

* `mask` is therefore a pattern indicating the bit of interest in the byte: it's
  1 at the bit corresponding to `n` and 0 elsewhere. If `n` is 21, then `mask`
  is 1 at the sixth bit, `00100000` (`1 << (n % 8) = 1 << 5 = 32 = 00100000`.

* `arr[byte] & mask` is the bitwise AND between the byte containing bit `n` and
  `mask`. The bitwise AND operation produces a new byte that has a 1 only where
  the two input bytes both have a 1. Therefore, because `mask` is 0 everywhere
  except for at the position of interest (`n % 8`), the result will equal `mask`
  only if that bit is enabled. For instance, assuming `n` is 21 such that `mask`
  is `00100000`,

  * If `arr[byte]` is `01010101`, then `arr[byte] & mask` is `00000000`, which
    does not equal `mask`, therefore bit `n` is not enabled (the cell is dead).

  * If `arr[byte]` is `01110101`, then `arr[byte] & mask` is `00100000`, which
    *does* equal `mask`, therefore bit `n` *is* enabled (the cell is alive).
